The input file consists of multiple 'blocks' where each block contains user-input
information. Currently, only the 'application' block is necessary and the others
are optional. Users can choose to input values of variable with the 'variables' 
block. The 'loop' block allows user to build loops (nested if necessary) where
the applications are executed which allows users to loop through variables with
different values. The 'application' block is where the information of the application
that is to be executed is inputted. Multiple 'application' blocks are acceptable
to allow for the coupling of different applications. The order of execution is
determine by the 'order' option in the block. The 'output' option allows users to
select the results that they wish to extract for postprocessing or use as inputs
to the next application. The 'operation' block allows simple operations to be
carried out for postprocessing. The 'plot' blocks allows simple plotting and 
visualization of the results.

watts{ 
	database_path = 'path-to-databse'[optional]

    workflow_level0 { # required - has "optimize" [optional] "iterate"  [optional] "parametric" [optional] - postprocess [optional]
		# workflow bock requires [variable and plugin] OR [sub-workflow].
		variables { # set of variables - we can define several sets - but need to be defined in each set
			params(Initial_Temp){value = 1500 , unit=optional, bonds=[1000, 1800]} % value = required - unit = optional [m, K, C, etc.] - ID = unique - bonds: required if optimization!
			params(Swelling_Coefficient){value = 3000 , unit=optional}
			params(Core_Diameter){value = 12 , unit=ft}
		}

		workflow_level1{ # optional

			optimize{ # this is for single criteria optimization?
				objective_functions = 'ID1[var1][0]'                      # variable to optimize
				method = 'SLSQP'                        # optimizatio algorithm - maybe different options (pymoo, etc.)
				tolerance = '1e-4'                      # convergence criteria
				options = ''                            # additional options
			}

			variables { # set of variables - we can define several sets - but need to be defined in each set
				params(Swelling_Coefficient){value = 3000 , unit=optional}
			}

			plugin(ID1)
		
			workflow_level2{  # optional
				iterate {
					nmax = 3 # required
					convergence ('ID1[var1][0]') = 1e-4
				}
				variables(VAR2) { # set of variables - we can define several sets - but need to be defined in each set
					params(Initial_Temp){value = 'ID1[var1][0]+ID2[var3][0]' , unit=optional} % value = required - unit = optional [m, K, C, etc.] - ID = unique
					params(Swelling_Coefficient){value = 'op2[0]' , unit=optional}
					params(Core_Diameter){value = 'ID2[var3][0]' , unit=ft}
				}
				plugin(ID1)
				plugin(ID2)
				postprocessor (post_process_2){		
					value = 'ID1[var4] + ID2[var7]'
				}
			}
			plugin(ID2)

		}
		workflow_level1{ # optional
			parametric{
				changing_params = Initial_Temp
				values_changin = [1000, 1500]
			}
			variables  { # set of variables - we can define several sets - but need to be defined in each set
					params(Initial_Temp){value = '1000' , unit=optional} % value = required - unit = optional [m, K, C, etc.] - ID = unique
					params(Swelling_Coefficient){value = 'op2[0]' , unit=optional}
					params(Core_Diameter){value = 'ID2[var3][0]' , unit=ft}
			}
			plugin(ID1)
			plugin(ID2)
		}

    }



    # For executing applications
    plugins{
	    plugin(ID1) { # ID is unique
	        code = 'SAM'                         # required
	        template = 'template.tmpl'                  # required
	        executable = './sam-opt'                    # optional if provided in bashrc
	        extra_input = ['main_in.e', 'sub.i']        # optional
	        output = ['var1', 'list_var2']              # optional - Save the outputs to something 
	        													     like dictionary that can accept
	        													     different data types. The saved 
	        													     outputs can be accessed in a
	        													     hierarchical manner like how values 
	        													     in Python dictionary are accessed. 
	        show_stderr = 'False'                       # optional
	        show_stdout = 'False'                       # optional
	        postprocessing = 'Name_of_operation'        # optional - Allows users to postprocess extracted results
	                                                    #            and store them in 'params' as input for the
	                                                    #            next application. The name of operation must
	                                                    #            match one of the operations in the 'operation' block.
	        ...
	    }
	
	    # For executing applications 
	    plugin (ID2){
	        code = 'PyARC'                       # required
	        template = 'template.tmpl'                  # required
	        executable = './PyARC.py'                   # optional if provided in bashrc
	        extra_input = ['main_in.e', 'sub.i']        # optional
	        output = ['var1', 'var2']                   # optional - names of variables to be extracted 
	        #this won't be straightforward!                                             #            post processing added to 'params' to 
	                                                    #            be used as input for the next application.
	        show_stderr = 'False'                       # optional
	        show_stdout = 'False'                       # optional
	        postprocessing = 'Name_of_operation'        # optional - Allows users to postprocess extracted results
	                                                    #            and store them in 'params' as input for the
	                                                    #            next application. The name of operation must
	                                                    #            match one of the operations in the 'operation' block.
	        ...
	    }
	}

}
